<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>将棋 AI & 1vs1</title>
    <style>
        :root {
            --board-color: #e3c878;
            --board-shadow: #bfa35a;
            --piece-bg: #fdf5e6;
            --piece-text: #1a1a1a;
            --promoted-text: #d32f2f;
            --overlay: rgba(0, 0, 0, 0.7);
        }

        body {
            font-family: "Helvetica Neue", Arial, sans-serif;
            background-color: #2b1d1a; color: white; margin: 0;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            min-height: 100vh; overflow: hidden; touch-action: manipulation;
        }

        .screen { display: none; flex-direction: column; align-items: center; }
        .screen.active { display: flex; }

        /* 王手通知 */
        #ote-notification {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 5rem; font-weight: 900; color: #ffeb3b; text-shadow: 0 0 20px #d32f2f, 0 0 40px #d32f2f;
            pointer-events: none; z-index: 200; opacity: 0; transition: opacity 0.3s ease;
            white-space: nowrap; font-family: "Yu Mincho", "MS PMincho", serif;
        }
        #ote-notification.show { opacity: 1; animation: pulse 0.8s infinite alternate; }
        @keyframes pulse { from { transform: translate(-50%, -50%) scale(1); } to { transform: translate(-50%, -50%) scale(1.1); } }

        /* モーダル */
        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--overlay); display: none; justify-content: center; align-items: center; z-index: 300;
        }
        .modal-content {
            background: #fdf5e6; color: #3e2723; padding: 30px; border-radius: 12px;
            text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.8); min-width: 280px;
        }

        /* メニュー */
        .menu-card {
            background: rgba(255, 255, 255, 0.1); padding: 40px; border-radius: 15px;
            text-align: center; border: 1px solid rgba(255, 255, 255, 0.2); width: 360px;
        }
        .option-group { margin-bottom: 20px; text-align: left; }
        .disabled { opacity: 0.3; pointer-events: none; }
        .option-group label { color: #e3c878; font-size: 0.9rem; margin-bottom: 5px; display: block; }
        select { width: 100%; padding: 12px; background: #fdf5e6; border-radius: 6px; font-size: 1rem; color: #3e2723; }

        .status-bar {
            font-size: 1.2rem; color: #e3c878; font-weight: bold; height: 35px; 
            display: flex; align-items: center; justify-content: center; width: 100%;
        }
        #status-p2 { transform: rotate(180deg); }

        .hand-box {
            background: #d7ccc8; color: #3e2723; padding: 5px 15px; border-radius: 6px;
            width: 558px; min-height: 55px; display: flex; align-items: center; justify-content: flex-start; gap: 10px;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.25); border: 1px solid #bcaaa4;
        }
        #hand-p2-container { transform: rotate(180deg); }

        #board-container { background: var(--board-shadow); padding: 12px; border-radius: 4px; box-shadow: 0 20px 50px rgba(0,0,0,0.8); }
        #board { display: grid; grid-template-columns: repeat(9, 62px); grid-template-rows: repeat(9, 64px); gap: 1px; background: #333; }
        .sq { width: 62px; height: 64px; background-color: var(--board-color); display: flex; justify-content: center; align-items: center; position: relative; cursor: pointer; }

        .piece {
            background: var(--piece-bg); color: var(--piece-text); display: flex; justify-content: center; align-items: center;
            font-family: "serif"; font-weight: 900; clip-path: polygon(50% 0%, 93% 18%, 100% 100%, 0% 100%, 7% 18%);
            box-shadow: inset 0 -4px 4px rgba(0,0,0,0.15); line-height: 1; pointer-events: none; z-index: 2;
            width: 55px; height: 60px; font-size: 38px;
        }
        .piece.p2-side { transform: rotate(180deg); }
        .piece.promoted { color: var(--promoted-text); }

        .sq.selected::after { content: ""; position: absolute; width: 100%; height: 100%; background: rgba(255, 235, 59, 0.4); z-index: 1; }
        .sq.last-move::after { content: ""; position: absolute; width: 100%; height: 100%; background: rgba(255, 87, 34, 0.4); z-index: 1; }

        .hand-piece {
            background: var(--piece-bg); width: 38px; height: 42px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; position: relative; font-weight: bold; border-radius: 3px; font-size: 24px; color: var(--piece-text);
            clip-path: polygon(50% 0%, 92% 18%, 100% 100%, 0% 100%, 8% 18%);
        }
        .hand-piece.selected { background: #fff176; outline: 3px solid #f44336; }
        .badge { position: absolute; bottom: -4px; right: -4px; background: #d32f2f; color: white; font-size: 10px; padding: 0px 4px; border-radius: 8px; border: 1px solid white; }

        .controls { margin-top: 15px; display: flex; gap: 10px; }
        button { padding: 12px 25px; background: #5d4037; color: white; border: none; cursor: pointer; border-radius: 6px; font-weight: bold; }

        /* スイッチスタイル */
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; vertical-align: middle; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #e3c878; }
        input:checked + .slider:before { transform: translateX(24px); }
    </style>
</head>
<body>

    <div id="ote-notification">王手！</div>

    <div id="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title"></h2>
            <div id="modal-body"></div>
            <div class="modal-btns" id="modal-btns"></div>
        </div>
    </div>

    <div id="home-screen" class="screen active">
        <div class="menu-card">
            <h1 style="letter-spacing: 4px; margin-top:0;">将棋 AI & 1vs1</h1>
            <div class="option-group">
                <label>1vs1 (対面対戦モード) <span style="float:right;"><label class="switch"><input type="checkbox" id="mode-1vs1" onchange="toggleAILevel()"><span class="slider"></span></label></span></label>
            </div>
            <div id="ai-level-group" class="option-group">
                <label>AI 難易度</label>
                <select id="ai-level"></select>
            </div>
            <div class="option-group">
                <label>手番選択</label>
                <select id="first-move">
                    <option value="p1">先手</option>
                    <option value="p2">後手</option>
                </select>
            </div>
            <button onclick="startGame()" style="width: 100%;">対局開始</button>
        </div>
    </div>

    <div id="game-screen" class="screen">
        <div id="status-p2" class="status-bar"></div>
        <div id="game-view">
            <div class="hand-box" id="hand-p2-container"><div id="hand-p2" style="display:flex; gap:5px;"></div></div>
            <div id="board-container"><div id="board"></div></div>
            <div class="hand-box" id="hand-p1-container"><div id="hand-p1" style="display:flex; gap:5px;"></div></div>
        </div>
        <div id="status-p1" class="status-bar"></div>
        <div class="controls">
            <button onclick="downloadKifu()">棋譜をダウンロード</button>
            <button onclick="location.reload()" style="background:#3e2723;">タイトルに戻る</button>
        </div>
    </div>

    <script>
        const PIECES = { 
            'K': '王', 'R': '飛', 'B': '角', 'G': '金', 'S': '銀', 'N': '桂', 'L': '香', 'P': '歩',
            'R+': '龍', 'B+': '馬', 'S+': '全', 'N+': '圭', 'L+': '杏', 'P+': 'と',
            'k': '玉', 'r': '飛', 'b': '角', 'g': '金', 's': '銀', 'n': '桂', 'l': '香', 'p': '歩',
            'r+': '龍', 'b+': '馬', 's+': '全', 'n+': '圭', 'l+': '杏', 'p+': 'と'
        };
        const SCORE = { 'K': 50000, 'R': 1000, 'B': 900, 'G': 600, 'S': 500, 'N': 400, 'L': 300, 'P': 100, 'R+': 1500, 'B+': 1300, 'S+': 700, 'N+': 700, 'L+': 700, 'P+': 700 };

        let board = [], handP1 = [], handP2 = [], kifuHistory = [];
        let selected = null, isTurnP1 = true, isGameOver = false, currentLevel = 20, lastMove = null, is1vs1 = false;

        // AI 20段階生成
        const levels = ["10級","9級","8級","7級","6級","5級","4級","3級","2級","1級","初段","二段","三段","四段","五段","六段","七段","八段","九段","十段"];
        const levelSelect = document.getElementById('ai-level');
        levels.forEach((l, i) => {
            const opt = document.createElement('option');
            opt.value = i + 1; opt.textContent = l;
            if(i === 19) opt.selected = true;
            levelSelect.appendChild(opt);
        });

        function toggleAILevel() {
            document.getElementById('ai-level-group').classList.toggle('disabled', document.getElementById('mode-1vs1').checked);
        }

        function startGame() {
            is1vs1 = document.getElementById('mode-1vs1').checked;
            currentLevel = parseInt(levelSelect.value);
            isTurnP1 = document.getElementById('first-move').value === 'p1';
            
            initBoard();
            document.getElementById('home-screen').classList.remove('active');
            document.getElementById('game-screen').classList.add('active');
            
            if (!isTurnP1 && !is1vs1) setTimeout(aiRoutine, 600);
            updateStatus(); render();
        }

        function initBoard() {
            board = [['l','n','s','g','k','g','s','n','l'],[' ','r',' ',' ',' ',' ',' ','b',' '],['p','p','p','p','p','p','p','p','p'],[' ',' ',' ',' ',' ',' ',' ',' ',' '],[' ',' ',' ',' ',' ',' ',' ',' ',' '],[' ',' ',' ',' ',' ',' ',' ',' ',' '],['P','P','P','P','P','P','P','P','P'],[' ','B',' ',' ',' ',' ',' ','R',' '],['L','N','S','G','K','G','S','N','L']];
            handP1 = []; handP2 = []; kifuHistory = []; isGameOver = false; lastMove = null;
        }

        function render() {
            const boardEl = document.getElementById('board'); boardEl.innerHTML = '';
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const sq = document.createElement('div'); sq.className = 'sq';
                    if (selected?.type === 'board' && selected.r === r && selected.c === c) sq.classList.add('selected');
                    if (lastMove?.tr === r && lastMove?.tc === c) sq.classList.add('last-move');
                    const p = board[r][c];
                    if (p !== ' ') {
                        const pEl = document.createElement('div');
                        pEl.className = `piece ${p === p.toLowerCase() ? 'p2-side' : ''} ${p.includes('+') ? 'promoted' : ''}`;
                        pEl.textContent = PIECES[p] || "";
                        sq.appendChild(pEl);
                    }
                    sq.onclick = () => onSquareClick(r, c);
                    boardEl.appendChild(sq);
                }
            }
            renderHand('hand-p1', handP1, true);
            renderHand('hand-p2', handP2, false);
        }

        function renderHand(id, hand, isP1) {
            const container = document.getElementById(id); container.innerHTML = '';
            const counts = {}; hand.forEach(p => counts[p] = (counts[p] || 0) + 1);
            Object.keys(counts).forEach(p => {
                const div = document.createElement('div');
                div.className = 'hand-piece' + (selected?.type === 'hand' && selected.piece === p && isTurnP1 === isP1 ? ' selected' : '');
                div.textContent = PIECES[p.toUpperCase()];
                if (counts[p] > 1) { const b = document.createElement('div'); b.className = 'badge'; b.textContent = counts[p]; div.appendChild(b); }
                div.onclick = (e) => { e.stopPropagation(); if(isTurnP1 === isP1) { selected = {type:'hand', piece:p}; render(); } };
                container.appendChild(div);
            });
        }

        function onSquareClick(r, c) {
            if (isGameOver || (!isTurnP1 && !is1vs1)) return;
            const p = board[r][c];
            if (selected) {
                if (selected.type === 'board') {
                    if (isValidMove(selected.r, selected.c, r, c, board)) {
                        const movePiece = board[selected.r][selected.c];
                        const canPromote = !movePiece.includes('+') && "PSNLBR".includes(movePiece.toUpperCase()) && (isTurnP1 ? r <= 2 : r >= 6);
                        if (canPromote) {
                            showModal("成り選択", "成りますか？", [
                                { label: "成る", action: () => executeMove(selected.r, selected.c, r, c, true) },
                                { label: "成らない", action: () => executeMove(selected.r, selected.c, r, c, false) }
                            ]);
                        } else executeMove(selected.r, selected.c, r, c, false);
                    }
                } else if (selected.type === 'hand') {
                    if (canDrop(selected.piece, r, c, isTurnP1, board)) {
                        board[r][c] = isTurnP1 ? selected.piece.toUpperCase() : selected.piece.toLowerCase();
                        const h = isTurnP1 ? handP1 : handP2; h.splice(h.indexOf(selected.piece), 1);
                        kifuHistory.push({ p: PIECES[board[r][c]], to: `${9-c}${r+1}`, drop: true });
                        completeTurn(r, c);
                    }
                }
                selected = null; render();
            } else if (p !== ' ' && (isTurnP1 ? p === p.toUpperCase() : p === p.toLowerCase())) {
                selected = { type: 'board', r, c }; render();
            }
        }

        function executeMove(fr, fc, tr, tc, promote) {
            let p = board[fr][fc];
            const target = board[tr][tc];
            if (target !== ' ') (isTurnP1 ? handP1 : handP2).push(target.replace('+', '').toUpperCase());
            if (promote) p += '+';
            board[tr][tc] = p; board[fr][fc] = ' ';
            kifuHistory.push({ p: PIECES[p], from: `${9-fc}${fr+1}`, to: `${9-tc}${tr+1}`, promote });
            completeTurn(tr, tc);
        }

        function completeTurn(tr, tc) {
            lastMove = { tr, tc }; isTurnP1 = !isTurnP1; updateStatus();
            if (isCheck(board, isTurnP1)) {
                if (getLegalMoves(board, isTurnP1).length === 0) {
                    const winner = !isTurnP1 ? "プレイヤー1" : (is1vs1 ? "プレイヤー2" : "AI");
                    endGame(`${winner} の勝利！`); return;
                }
                showOte();
            }
            render();
            if (!isTurnP1 && !is1vs1 && !isGameOver) setTimeout(aiRoutine, 600);
        }

        function isValidMove(fr, fc, tr, tc, b) {
            const p = b[fr][fc]; const tp = b[tr][tc];
            if (tp !== ' ' && (p === p.toUpperCase()) === (tp === tp.toUpperCase())) return false;
            const dr = tr-fr, dc = tc-fc, adr = Math.abs(dr), adc = Math.abs(dc), s = p === p.toUpperCase() ? -1 : 1;
            if (p.includes('+')) {
                const base = p.replace('+', '').toUpperCase();
                if (base === 'R') return (dr === 0 || dc === 0 || (adr === 1 && adc === 1)) && isClear(fr,fc,tr,tc,b);
                if (base === 'B') return (adr === adc || (adr === 1 && dc === 0) || (adc === 1 && dr === 0)) && isClear(fr,fc,tr,tc,b);
                return (adr <= 1 && adc <= 1) && !(dr === -s && adc === 1);
            }
            switch(p.toUpperCase()) {
                case 'P': return dc === 0 && dr === s;
                case 'L': return dc === 0 && dr*s > 0 && isClear(fr,fc,tr,tc,b);
                case 'N': return dr === s*2 && adc === 1;
                case 'S': return (adr === 1 && adc === 1) || (dr === s && dc === 0);
                case 'G': return (adr <= 1 && adc <= 1) && !(dr === -s && adc === 1);
                case 'K': return adr <= 1 && adc <= 1;
                case 'B': return adr === adc && isClear(fr,fc,tr,tc,b);
                case 'R': return (dr === 0 || dc === 0) && isClear(fr,fc,tr,tc,b);
            }
            return false;
        }

        function isClear(fr, fc, tr, tc, b) {
            const sr = Math.sign(tr-fr), sc = Math.sign(tc-fc);
            let r = fr+sr, c = fc+sc;
            while(r!==tr || c!==tc){ if(b[r][c]!==' ') return false; r+=sr; c+=sc; }
            return true;
        }

        function canDrop(p, tr, tc, isP1, b) {
            if (b[tr][tc] !== ' ') return false;
            if ((p==='P' || p==='L') && (isP1 ? tr===0 : tr===8)) return false;
            if (p==='N' && (isP1 ? tr<=1 : tr>=7)) return false;
            if (p==='P') for(let r=0; r<9; r++) if(b[r][tc] === (isP1?'P':'p')) return false;
            return true;
        }

        function isCheck(b, isP1) {
            let kr, kc; const target = isP1 ? 'K' : 'k';
            for(let r=0; r<9; r++) for(let c=0; c<9; c++) if(b[r][c] === target) { kr=r; kc=c; }
            if(kr === undefined) return false;
            for(let r=0; r<9; r++) for(let c=0; c<9; c++)
                if(b[r][c] !== ' ' && (b[r][c] === b[r][c].toUpperCase()) !== isP1)
                    if(isValidMove(r, c, kr, kc, b)) return true;
            return false;
        }

        function getLegalMoves(b, isP1) {
            let moves = [];
            for(let r=0; r<9; r++) for(let c=0; c<9; c++) {
                if(b[r][c] !== ' ' && (b[r][c] === b[r][c].toUpperCase()) === isP1) {
                    for(let tr=0; tr<9; tr++) for(let tc=0; tc<9; tc++) {
                        if(isValidMove(r, c, tr, tc, b)) {
                            let nb = b.map(row => [...row]); nb[tr][tc] = nb[r][c]; nb[r][c] = ' ';
                            if(!isCheck(nb, isP1)) moves.push({type:'move', fr:r, fc:c, tr, tc});
                        }
                    }
                }
            }
            const h = isP1 ? handP1 : handP2;
            [...new Set(h)].forEach(p => {
                for(let tr=0; tr<9; tr++) for(let tc=0; tc<9; tc++)
                    if(canDrop(p, tr, tc, isP1, b)) {
                        let nb = b.map(row => [...row]); nb[tr][tc] = isP1 ? p : p.toLowerCase();
                        if(!isCheck(nb, isP1)) moves.push({type:'drop', piece:p, tr, tc});
                    }
            });
            return moves;
        }

        function aiRoutine() {
            if (isGameOver) return;
            const moves = getLegalMoves(board, false);
            if (moves.length === 0) { endGame("プレイヤー1 の勝利！"); return; }
            
            let best = moves[0]; let maxS = -Infinity;
            moves.forEach(m => {
                let s = 0;
                if(m.type === 'move') {
                    const target = board[m.tr][m.tc];
                    if(target !== ' ') s += SCORE[target.toUpperCase()] || 0;
                    s += (m.tr) * 10; // 敵陣への接近評価
                }
                if(s > maxS) { maxS = s; best = m; }
            });

            if(best.type === 'move') executeMove(best.fr, best.fc, best.tr, best.tc, (best.tr >= 6 && !board[best.fr][best.fc].includes('+')));
            else {
                board[best.tr][best.tc] = best.piece.toLowerCase();
                handP2.splice(handP2.indexOf(best.piece), 1);
                kifuHistory.push({ p: PIECES[best.piece], to: `${9-best.tc}${best.tr+1}`, drop: true });
                completeTurn(best.tr, best.tc);
            }
        }

        function updateStatus() {
            const p1 = document.getElementById('status-p1'); const p2 = document.getElementById('status-p2');
            if(isGameOver) return;
            p1.textContent = isTurnP1 ? (is1vs1 ? "プレイヤー1の手番" : "あなたの手番") : "";
            p2.textContent = !isTurnP1 ? (is1vs1 ? "プレイヤー2の手番" : "AI思考中...") : "";
        }

        function endGame(msg) {
            isGameOver = true;
            document.getElementById('status-p1').textContent = "対局終了";
            document.getElementById('status-p2').textContent = "対局終了";
            showModal("終局", msg, [{ label: "タイトルへ", action: () => location.reload() }]);
        }

        function showModal(title, body, btns) {
            const over = document.getElementById('modal-overlay');
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-body').textContent = body;
            const container = document.getElementById('modal-btns'); container.innerHTML = '';
            btns.forEach(b => {
                const btn = document.createElement('button'); btn.textContent = b.label;
                btn.onclick = () => { b.action(); over.style.display = 'none'; };
                container.appendChild(btn);
            });
            over.style.display = 'flex';
        }

        function showOte() {
            const n = document.getElementById('ote-notification'); n.classList.add('show');
            setTimeout(() => n.classList.remove('show'), 1000);
        }

        function downloadKifu() {
            let csv = "手数,駒,移動元,移動先,備考\n";
            kifuHistory.forEach((h, i) => {
                csv += `${i+1},${h.p},${h.from || '打'},${h.to},${h.promote ? '成' : ''}\n`;
            });
            const blob = new Blob(["\ufeff", csv], { type: 'text/csv' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
            a.download = `kifu_${new Date().getTime()}.csv`; a.click();
        }
    </script>
</body>
</html>
