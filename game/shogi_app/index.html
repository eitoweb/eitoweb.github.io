<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>将棋 Premium - Strong AI Edition</title>
    <style>
        :root {
            --board-color: #e3c878;
            --board-shadow: #bfa35a;
            --piece-bg: #fdf5e6;
            --piece-text: #1a1a1a;
            --promoted-text: #d32f2f;
            --overlay: rgba(0, 0, 0, 0.8);
            --accent: #e3c878;
        }

        body {
            font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", sans-serif;
            background-color: #1a1210; color: white; margin: 0;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            min-height: 100vh; overflow: hidden; touch-action: manipulation;
        }

        .screen { display: none; flex-direction: column; align-items: center; width: 100%; animation: fadeIn 0.5s; }
        .screen.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .menu-card {
            background: linear-gradient(145deg, #3d2b27, #2b1d1a);
            padding: 40px; border-radius: 24px; text-align: center;
            border: 1px solid rgba(227, 200, 120, 0.3); width: 380px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        h1 { font-size: 2rem; letter-spacing: 6px; margin-bottom: 30px; color: var(--accent); text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .option-group { margin-bottom: 25px; text-align: left; }
        .option-group label { color: #ccc; font-size: 0.85rem; margin-bottom: 8px; display: block; font-weight: bold; }
        
        select { 
            width: 100%; padding: 14px; background: #fdf5e6; border: none; border-radius: 8px; 
            font-size: 1rem; color: #3e2723; font-weight: bold; cursor: pointer;
        }

        .start-btn {
            width: 100%; padding: 16px; background: var(--accent); color: #3e2723;
            border: none; border-radius: 12px; font-size: 1.2rem; font-weight: 900;
            cursor: pointer; transition: transform 0.2s, background 0.2s; margin-top: 10px;
        }

        .status-bar { font-size: 1.1rem; color: var(--accent); font-weight: bold; height: 40px; display: flex; align-items: center; transition: all 0.3s; white-space: nowrap; }
        .active-turn { text-shadow: 0 0 10px var(--accent); color: white; scale: 1.1; }

        #board-container { 
            background: var(--board-shadow); padding: 10px; border-radius: 8px; 
            box-shadow: 0 15px 35px rgba(0,0,0,0.6); border: 1px solid #8d7042;
        }
        #board { display: grid; grid-template-columns: repeat(9, 62px); grid-template-rows: repeat(9, 64px); gap: 1px; background: #5d4037; }
        .sq { width: 62px; height: 64px; background-color: var(--board-color); display: flex; justify-content: center; align-items: center; position: relative; cursor: pointer; }

        .piece {
            background: var(--piece-bg); color: var(--piece-text); display: flex; justify-content: center; align-items: center;
            font-family: "Yu Mincho", "serif"; font-weight: 900; clip-path: polygon(50% 0%, 93% 18%, 100% 100%, 0% 100%, 7% 18%);
            box-shadow: inset 0 -4px 4px rgba(0,0,0,0.1); line-height: 1; pointer-events: none; z-index: 2;
        }
        .piece.p2-side { transform: rotate(180deg); }
        .piece.promoted { color: var(--promoted-text); }
        
        .p-K { width: 56px; height: 61px; font-size: 40px; }
        .p-R, .p-B { width: 53px; height: 58px; font-size: 36px; }
        .p-G, .p-S { width: 50px; height: 55px; font-size: 34px; }
        .p-N, .p-L { width: 46px; height: 51px; font-size: 30px; }
        .p-P { width: 42px; height: 46px; font-size: 26px; }

        .sq.selected::after { content: ""; position: absolute; inset: 2px; border: 3px solid #ffeb3b; border-radius: 4px; z-index: 3; pointer-events: none; }
        .sq.last-move::after { content: ""; position: absolute; inset: 0; background: rgba(255, 87, 34, 0.4); z-index: 1; pointer-events: none; }

        .hand-box {
            background: rgba(0,0,0,0.2); border-radius: 8px; width: 558px; min-height: 55px;
            display: flex; align-items: center; gap: 12px; padding: 6px 16px; margin: 8px 0;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .hand-piece {
            background: transparent; width: 44px; height: 48px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; position: relative; font-weight: bold; font-size: 24px; color: var(--piece-text);
            overflow: visible !important; flex-shrink: 0;
        }
        .hand-piece-inner {
            background: var(--piece-bg); width: 100%; height: 100%; display: flex; justify-content: center; align-items: center;
            clip-path: polygon(50% 0%, 93% 18%, 100% 100%, 0% 100%, 7% 18%);
        }
        .hand-piece.selected { outline: 3px solid #ffeb3b; border-radius: 4px; box-shadow: 0 0 15px #ffeb3b; }
        
        .badge { 
            position: absolute; top: -8px; right: -12px;
            background: #d32f2f; color: white; 
            font-size: 14px; min-width: 24px; height: 24px; border-radius: 12px;
            display: flex; align-items: center; justify-content: center;
            border: 2px solid #fff; font-weight: 900; pointer-events: none; z-index: 9999;
            box-shadow: 0 2px 6px rgba(0,0,0,0.6);
            line-height: 1;
        }

        #modal-overlay {
            position: fixed; inset: 0; background: var(--overlay); display: none;
            justify-content: center; align-items: center; z-index: 1000; backdrop-filter: blur(4px);
        }
        .modal-content {
            background: #fdf5e6; color: #3e2723; padding: 30px; border-radius: 20px;
            text-align: center; width: 320px; box-shadow: 0 25px 50px rgba(0,0,0,0.5);
        }
        .modal-btns { display: flex; gap: 10px; margin-top: 20px; }
        .modal-btn { flex: 1; padding: 12px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1rem; }
        .btn-confirm { background: #5d4037; color: white; }
        .btn-cancel { background: #ccc; color: #333; }

        .switch-container { display: flex; align-items: center; justify-content: space-between; cursor: pointer; }
        .switch { position: relative; width: 50px; height: 26px; background: #555; border-radius: 13px; transition: 0.3s; }
        .switch::after { content: ""; position: absolute; width: 22px; height: 22px; background: white; border-radius: 50%; top: 2px; left: 2px; transition: 0.3s; }
        input:checked + .switch { background: var(--accent); }
        input:checked + .switch::after { left: 26px; }

        #ote-notification {
            position: fixed; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 900; 
            font-size: 5rem; font-weight: 900; color: #ffeb3b; 
            text-shadow: 0 0 20px red; opacity: 0; transition: 0.3s;
            white-space: nowrap;
        }
    </style>
</head>
<body>

    <div id="ote-notification">王手！</div>

    <div id="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title" style="margin-top:0;">確認</h2>
            <p id="modal-body"></p>
            <div class="modal-btns" id="modal-btns"></div>
        </div>
    </div>

    <div id="home-screen" class="screen active">
        <div class="menu-card">
            <h1>将棋 Premium</h1>
            <div class="option-group">
                <label class="switch-container">
                    <span>1vs1 モード (対面対戦)</span>
                    <div style="position:relative;">
                        <input type="checkbox" id="mode-1vs1" style="display:none;" onchange="toggleAILevelUI()">
                        <div class="switch"></div>
                    </div>
                </label>
            </div>
            <div id="ai-level-group" class="option-group">
                <label>AI 難易度</label>
                <select id="ai-level"></select>
            </div>
            <div id="ai-style-group" class="option-group">
                <label>AI 戦型</label>
                <select id="ai-style">
                    <option value="balance">バランス（標準）</option>
                    <option value="ibisha">居飛車（正攻法）</option>
                    <option value="furibisha">振り飛車（カウンター）</option>
                </select>
            </div>
            <div class="option-group">
                <label>先手選択</label>
                <select id="first-move">
                    <option value="p1">プレイヤー1 (下側)</option>
                    <option value="p2">プレイヤー2 / AI (上側)</option>
                    <option value="random">ランダム</option>
                </select>
            </div>
            <button class="start-btn" onclick="startGame()">対局開始</button>
        </div>
    </div>

    <div id="game-screen" class="screen">
        <div id="status-p2" class="status-bar"></div>
        <div class="hand-box" id="hand-p2-container" style="transform: rotate(180deg);"><div id="hand-p2" style="display:flex; gap:16px;"></div></div>
        <div id="board-container"><div id="board"></div></div>
        <div class="hand-box" id="hand-p1-container"><div id="hand-p1" style="display:flex; gap:16px;"></div></div>
        <div id="status-p1" class="status-bar"></div>
        <div style="margin-top:20px; display:flex; gap:15px;">
            <button onclick="downloadKifu()" style="background:#444; color:white; border:none; padding:10px 20px; border-radius:8px; font-weight:bold; cursor:pointer;">棋譜DL</button>
            <button onclick="location.reload()" style="background:#3e2723; color:white; border:none; padding:10px 20px; border-radius:8px; font-weight:bold; cursor:pointer;">終了</button>
        </div>
    </div>

    <script>
        const PIECE_DATA = {
            'K': {name:'王', size:'p-K'}, 'R': {name:'飛', size:'p-R'}, 'B': {name:'角', size:'p-B'},
            'G': {name:'金', size:'p-G'}, 'S': {name:'銀', size:'p-S'}, 'N': {name:'桂', size:'p-N'},
            'L': {name:'香', size:'p-L'}, 'P': {name:'歩', size:'p-P'},
            'R+': {name:'龍', size:'p-R'}, 'B+': {name:'馬', size:'p-B'}, 'S+': {name:'全', size:'p-S'},
            'N+': {name:'圭', size:'p-N'}, 'L+': {name:'杏', size:'p-L'}, 'P+': {name:'と', size:'p-P'}
        };
        const SCORES = { 'K':100000, 'R':1200, 'B':1100, 'G':600, 'S':500, 'N':400, 'L':300, 'P':100, 'R+':1700, 'B+':1500, 'S+':700, 'N+':700, 'L+':700, 'P+':700 };

        let board = [], handP1 = [], handP2 = [], kifu = [], history = [];
        let isTurnP1 = true, isGameOver = false, selected = null, is1vs1 = false, level = 20, aiStyle = 'balance', lastMove = null;

        const lvSelect = document.getElementById('ai-level');
        const lvNames = ["10級","9級","8級","7級","6級","5級","4級","3級","2級","1級","初段","二段","三段","四段","五段","六段","七段","八段","九段","十段"];
        lvNames.forEach((n, i) => {
            const opt = document.createElement('option');
            opt.value = i + 1; opt.textContent = n;
            if(i === 19) opt.selected = true;
            lvSelect.appendChild(opt);
        });

        function toggleAILevelUI() {
            const is1v1 = document.getElementById('mode-1vs1').checked;
            document.getElementById('ai-level-group').style.opacity = is1v1 ? "0.3" : "1";
            document.getElementById('ai-style-group').style.opacity = is1v1 ? "0.3" : "1";
        }

        function startGame() {
            is1vs1 = document.getElementById('mode-1vs1').checked;
            level = parseInt(lvSelect.value);
            aiStyle = document.getElementById('ai-style').value;
            const first = document.getElementById('first-move').value;
            isTurnP1 = (first === 'p1') ? true : (first === 'p2' ? false : Math.random() < 0.5);
            initGame();
            document.getElementById('home-screen').classList.remove('active');
            document.getElementById('game-screen').classList.add('active');
            updateStatus();
            render();
            recordPosition();
            if(!isTurnP1 && !is1vs1) setTimeout(aiAction, 800);
        }

        function initGame() {
            board = [['l','n','s','g','k','g','s','n','l'],[' ','r',' ',' ',' ',' ',' ','b',' '],['p','p','p','p','p','p','p','p','p'],[' ',' ',' ',' ',' ',' ',' ',' ',' '],[' ',' ',' ',' ',' ',' ',' ',' ',' '],[' ',' ',' ',' ',' ',' ',' ',' ',' '],['P','P','P','P','P','P','P','P','P'],[' ','B',' ',' ',' ',' ',' ','R',' '],['L','N','S','G','K','G','S','N','L']];
            handP1 = []; handP2 = []; kifu = []; history = []; isGameOver = false; lastMove = null;
        }

        function getPositionKey(b, h1, h2, turn) {
            return JSON.stringify({b:b, h1:h1.slice().sort(), h2:h2.slice().sort(), t:turn});
        }

        function recordPosition() {
            const pos = getPositionKey(board, handP1, handP2, isTurnP1);
            history.push(pos);
            checkSennichite(pos);
        }

        function checkSennichite(currentPos) {
            const count = history.filter(p => p === currentPos).length;
            if (count >= 4) {
                finishGame("千日手により引き分けです。");
            }
        }

        function render() {
            const bEl = document.getElementById('board'); bEl.innerHTML = '';
            for(let r=0; r<9; r++) {
                for(let c=0; c<9; c++) {
                    const sq = document.createElement('div');
                    sq.className = 'sq';
                    if(selected?.type === 'board' && selected?.r === r && selected?.c === c) sq.classList.add('selected');
                    if(lastMove?.tr === r && lastMove?.tc === c) sq.classList.add('last-move');
                    const p = board[r][c];
                    if(p !== ' ') {
                        const pEl = document.createElement('div');
                        const isP2 = p === p.toLowerCase();
                        pEl.className = `piece ${isP2 ? 'p2-side' : ''} ${p.includes('+') ? 'promoted' : ''} ${PIECE_DATA[p.toUpperCase()]?.size}`;
                        pEl.textContent = PIECE_DATA[p.toUpperCase()]?.name;
                        sq.appendChild(pEl);
                    }
                    sq.onclick = () => handleSquareClick(r, c);
                    bEl.appendChild(sq);
                }
            }
            renderHand('hand-p1', handP1, true);
            renderHand('hand-p2', handP2, false);
        }

        function renderHand(id, hand, isP1) {
            const el = document.getElementById(id); el.innerHTML = '';
            const counts = {}; hand.forEach(x => counts[x] = (counts[x]||0)+1);
            Object.keys(counts).sort().forEach(p => {
                const d = document.createElement('div');
                d.className = 'hand-piece' + (selected?.type === 'hand' && selected.piece === p && isTurnP1 === isP1 ? ' selected' : '');
                
                const inner = document.createElement('div');
                inner.className = 'hand-piece-inner';
                inner.textContent = PIECE_DATA[p]?.name;
                d.appendChild(inner);

                if(counts[p] > 1) { 
                    const b = document.createElement('div'); b.className='badge'; b.textContent=counts[p]; 
                    d.appendChild(b); 
                }
                d.onclick = (e) => { e.stopPropagation(); if(isTurnP1 === isP1) { selected = {type:'hand', piece:p}; render(); }};
                el.appendChild(d);
            });
        }

        function handleSquareClick(r, c) {
            if(isGameOver || (!isTurnP1 && !is1vs1)) return;
            const p = board[r][c];
            if(selected) {
                const moves = getLegalMoves(board, isTurnP1, handP1, handP2);
                const move = moves.find(m => m.tr === r && m.tc === c && (selected.type === 'board' ? (m.fr === selected.r && m.fc === selected.c) : (m.piece === selected.piece)));
                if(move) {
                    if(move.type === 'move') {
                        const pc = board[move.fr][move.fc];
                        const isPromotable = !pc.includes('+') && "PSNLBR".includes(pc.toUpperCase()) && (isTurnP1 ? r <= 2 || move.fr <= 2 : r >= 6 || move.fr >= 6);
                        const forcePromote = (pc.toUpperCase()==='P' || pc.toUpperCase()==='L') && (isTurnP1 ? r===0 : r===8) || (pc.toUpperCase()==='N' && (isTurnP1 ? r<=1 : r>=7));
                        const fr = move.fr, fc = move.fc; selected = null;
                        if(forcePromote) executeMove(fr, fc, r, c, true);
                        else if(isPromotable) {
                            showModal("成り", "成りますか？", [
                                { label: "成る", class: "btn-confirm", action: () => executeMove(fr, fc, r, c, true) },
                                { label: "成らない", class: "btn-cancel", action: () => executeMove(fr, fc, r, c, false) }
                            ]);
                        } else executeMove(fr, fc, r, c, false);
                    } else {
                        board[r][c] = isTurnP1 ? selected.piece : selected.piece.toLowerCase();
                        const h = isTurnP1 ? handP1 : handP2; h.splice(h.indexOf(selected.piece), 1);
                        kifu.push(`打${9-c}${r+1}${PIECE_DATA[selected.piece].name}`);
                        selected = null; endTurn(r, c);
                    }
                    return;
                }
                selected = null; render();
            } else if(p !== ' ' && (isTurnP1 ? p === p.toUpperCase() : p === p.toLowerCase())) {
                selected = {type:'board', r, c}; render();
            }
        }

        function executeMove(fr, fc, tr, tc, promote) {
            let p = board[fr][fc]; const target = board[tr][tc];
            if(target !== ' ') (isTurnP1 ? handP1 : handP2).push(target.replace('+', '').toUpperCase());
            if(promote) p += '+'; board[tr][tc] = p; board[fr][fc] = ' ';
            kifu.push(`${9-fc}${fr+1}${9-tc}${tc+1}${PIECE_DATA[p.toUpperCase()].name}${promote?'成':''}`);
            endTurn(tr, tc);
        }

        function endTurn(tr, tc) {
            lastMove = {tr, tc}; isTurnP1 = !isTurnP1; 
            render(); 
            updateStatus();
            recordPosition();
            if (isGameOver) return;
            if(isCheck(board, isTurnP1)) {
                if(getLegalMoves(board, isTurnP1, handP1, handP2).length === 0) { finishGame(!isTurnP1 ? "プレイヤー1の勝利！" : "AIの勝利！"); return; }
                flashOte();
            } else if(getLegalMoves(board, isTurnP1, handP1, handP2).length === 0) finishGame("詰み（ステイルメイト）");
            if(!isTurnP1 && !is1vs1) setTimeout(aiAction, 300);
        }

        // --- AI Algorithm Section ---

        function evaluateBoard(b, h1, h2) {
            let score = 0;
            for(let r=0; r<9; r++) {
                for(let c=0; c<9; c++) {
                    const p = b[r][c];
                    if(p === ' ') continue;
                    const val = SCORES[p.toUpperCase()];
                    const isP1 = p === p.toUpperCase();
                    let bonus = 0;
                    
                    // 位置評価 (簡易版PST)
                    if(p.toUpperCase() === 'K') {
                        bonus = isP1 ? (r >= 7 ? 20 : -50) : (r <= 1 ? 20 : -50);
                    } else if(p.toUpperCase() === 'P') {
                        bonus = isP1 ? (8-r)*5 : r*5;
                    }
                    
                    score += isP1 ? (val + bonus) : -(val + bonus);
                }
            }
            h1.forEach(p => score += SCORES[p] * 1.1);
            h2.forEach(p => score -= SCORES[p] * 1.1);
            return score;
        }

        function alphaBeta(b, h1, h2, depth, alpha, beta, isP1) {
            if(depth === 0) return evaluateBoard(b, h1, h2);

            const moves = getLegalMoves(b, isP1, h1, h2);
            if(moves.length === 0) return isP1 ? -999999 : 999999;

            if(isP1) {
                let v = -Infinity;
                for(const m of moves) {
                    const {nb, nh1, nh2} = simulateMove(b, h1, h2, m, true);
                    v = Math.max(v, alphaBeta(nb, nh1, nh2, depth - 1, alpha, beta, false));
                    alpha = Math.max(alpha, v);
                    if(beta <= alpha) break;
                }
                return v;
            } else {
                let v = Infinity;
                for(const m of moves) {
                    const {nb, nh1, nh2} = simulateMove(b, h1, h2, m, false);
                    v = Math.min(v, alphaBeta(nb, nh1, nh2, depth - 1, alpha, beta, true));
                    beta = Math.min(beta, v);
                    if(beta <= alpha) break;
                }
                return v;
            }
        }

        function simulateMove(b, h1, h2, m, isP1) {
            let nb = b.map(row => [...row]);
            let nh1 = [...h1], nh2 = [...h2];
            if(m.type === 'move') {
                let p = nb[m.fr][m.fc];
                const target = nb[m.tr][m.tc];
                if(target !== ' ') (isP1 ? nh1 : nh2).push(target.replace('+','').toUpperCase());
                // AIのシミュレーションでは簡易的に成れるなら成る
                if(!p.includes('+') && "PSNLBR".includes(p.toUpperCase()) && (isP1 ? m.tr <= 2 : m.tr >= 6)) p += '+';
                nb[m.tr][m.tc] = p; nb[m.fr][m.fc] = ' ';
            } else {
                nb[m.tr][m.tc] = isP1 ? m.piece : m.piece.toLowerCase();
                (isP1 ? nh1 : nh2).splice((isP1 ? nh1 : nh2).indexOf(m.piece), 1);
            }
            return {nb, nh1, nh2};
        }

        function aiAction() {
            if(isGameOver) return;
            const moves = getLegalMoves(board, false, handP1, handP2);
            if(moves.length === 0) return;

            // 探索深さ：十段は4手先、それ以外は難易度に応じて調整
            const searchDepth = level >= 15 ? 3 : (level >= 10 ? 2 : 1);
            let bestMove = null;
            let minScore = Infinity;

            // 候補手を評価
            for(const m of moves) {
                const {nb, nh1, nh2} = simulateMove(board, handP1, handP2, m, false);
                
                // 千日手チェック (AIは既出局面を避ける)
                const key = getPositionKey(nb, nh1, nh2, true);
                if(history.includes(key)) continue;

                const score = alphaBeta(nb, nh1, nh2, searchDepth, -Infinity, Infinity, true);
                
                if(score < minScore) {
                    minScore = score;
                    bestMove = m;
                }
            }

            if(!bestMove) bestMove = moves[Math.floor(Math.random()*moves.length)];

            if(bestMove.type === 'move') {
                const pc = board[bestMove.fr][bestMove.fc];
                const force = (pc === 'p' || pc === 'l') && bestMove.tr === 8 || (pc === 'n' && bestMove.tr >= 7);
                const autoPromote = !pc.includes('+') && "PSNLBR".includes(pc.toUpperCase()) && (bestMove.tr >= 6);
                executeMove(bestMove.fr, bestMove.fc, bestMove.tr, bestMove.tc, autoPromote || force);
            } else {
                board[bestMove.tr][bestMove.tc] = bestMove.piece.toLowerCase();
                handP2.splice(handP2.indexOf(bestMove.piece), 1);
                kifu.push(`打${9-bestMove.tc}${bestMove.tr+1}${PIECE_DATA[bestMove.piece].name}`);
                endTurn(bestMove.tr, bestMove.tc);
            }
        }

        // --- Core Rules Section ---

        function canMove(fr, fc, tr, tc, b) {
            const p = b[fr][fc]; const target = b[tr][tc];
            if(target !== ' ' && (p === p.toUpperCase()) === (target === target.toUpperCase())) return false;
            const dr = tr-fr, dc = tc-fc, adr = Math.abs(dr), adc = Math.abs(dc), s = p === p.toUpperCase() ? -1 : 1;
            if(p.includes('+')) {
                const base = p.replace('+', '').toUpperCase();
                if(base === 'R') return (dr===0 || dc===0 || (adr===1 && adc===1)) && isPathClear(fr,fc,tr,tc,b);
                if(base === 'B') return (adr===adc || (adr===1 && dc===0) || (adc===1 && dr===0)) && isPathClear(fr,fc,tr,tc,b);
                return adr<=1 && adc<=1 && !(dr===-s && adc===1);
            }
            switch(p.toUpperCase()) {
                case 'P': return dc===0 && dr===s;
                case 'L': return dc===0 && dr*s>0 && isPathClear(fr,fc,tr,tc,b);
                case 'N': return dr===s*2 && adc===1;
                case 'S': return (adr===1 && adc===1) || (dr===s && dc===0);
                case 'G': return adr<=1 && adc<=1 && !(dr===-s && adc===1);
                case 'K': return adr<=1 && adc<=1;
                case 'R': return (dr===0 || dc===0) && isPathClear(fr,fc,tr,tc,b);
                case 'B': return adr===adc && isPathClear(fr,fc,tr,tc,b);
            }
            return false;
        }

        function isPathClear(fr, fc, tr, tc, b) {
            const sr = Math.sign(tr-fr), sc = Math.sign(tc-fc);
            let r = fr+sr, c = fc+sc;
            while(r!==tr || c!==tc) { if(b[r][c] !== ' ') return false; r+=sr; c+=sc; }
            return true;
        }

        function canDrop(p, tr, tc, isP1, b) {
            if(b[tr][tc] !== ' ') return false;
            if((p==='P'||p==='L') && (isP1?tr===0:tr===8)) return false;
            if(p==='N' && (isP1?tr<=1:tr>=7)) return false;
            if(p==='P') for(let r=0; r<9; r++) if(b[r][tc] === (isP1?'P':'p')) return false;
            return true;
        }

        function isCheck(b, isP1) {
            let kr, kc; const target = isP1 ? 'K' : 'k';
            for(let r=0; r<9; r++) for(let c=0; c<9; c++) if(b[r][c] === target) { kr=r; kc=c; }
            if(kr === undefined) return false;
            for(let r=0; r<9; r++) for(let c=0; c<9; c++) {
                const p = b[r][c]; if(p !== ' ' && (p === p.toUpperCase()) !== isP1) if(canMove(r, c, kr, kc, b)) return true;
            }
            return false;
        }

        function getLegalMoves(b, isP1, h1, h2) {
            let moves = [];
            for(let r=0; r<9; r++) for(let c=0; c<9; c++) {
                if(b[r][c] !== ' ' && (b[r][c] === b[r][c].toUpperCase()) === isP1) {
                    for(let tr=0; tr<9; tr++) for(let tc=0; tc<9; tc++) {
                        if(canMove(r, c, tr, tc, b)) {
                            let nb = b.map(row => [...row]); nb[tr][tc] = nb[r][c]; nb[r][c] = ' ';
                            if(!isCheck(nb, isP1)) moves.push({type:'move', fr:r, fc:c, tr, tc});
                        }
                    }
                }
            }
            const h = isP1 ? h1 : h2;
            [...new Set(h)].forEach(p => {
                for(let tr=0; tr<9; tr++) for(let tc=0; tc<9; tc++) if(canDrop(p, tr, tc, isP1, b)) {
                    let nb = b.map(row => [...row]); nb[tr][tc] = isP1 ? p : p.toLowerCase();
                    if(!isCheck(nb, isP1)) moves.push({type:'drop', piece:p, tr, tc});
                }
            });
            return moves;
        }

        function updateStatus() {
            const s1 = document.getElementById('status-p1'), s2 = document.getElementById('status-p2');
            s1.className = 'status-bar' + (isTurnP1 ? ' active-turn' : '');
            s2.className = 'status-bar' + (!isTurnP1 ? ' active-turn' : '');
            if(is1vs1) {
                s2.style.transform = "rotate(180deg)";
                s1.textContent = isTurnP1 ? "プレイヤー1の手番" : "";
                s2.textContent = !isTurnP1 ? "プレイヤー2の手番" : "";
            } else {
                s2.style.transform = "rotate(0deg)";
                s1.textContent = isTurnP1 ? "あなたの手番" : "";
                s2.textContent = !isTurnP1 ? `AI思考中... (Alpha-Beta Search)` : "";
            }
        }

        function showModal(title, body, btns) {
            const over = document.getElementById('modal-overlay');
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-body').textContent = body;
            const container = document.getElementById('modal-btns'); container.innerHTML = '';
            btns.forEach(b => {
                const btn = document.createElement('button'); btn.className = `modal-btn ${b.class}`; btn.textContent = b.label;
                btn.onclick = (e) => { e.preventDefault(); b.action(); over.style.display = 'none'; };
                container.appendChild(btn);
            });
            over.style.display = 'flex';
        }

        function flashOte() {
            const el = document.getElementById('ote-notification');
            el.style.opacity = 1; setTimeout(() => el.style.opacity = 0, 1000);
        }

        function finishGame(msg) {
            isGameOver = true;
            showModal("対局終了", msg, [{ label: "タイトルへ", class: "btn-confirm", action: () => location.reload() }]);
        }

        function downloadKifu() {
            const blob = new Blob(["\ufeff" + kifu.join('\n')], {type:'text/plain'});
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
            a.download = 'shogi_kifu.txt'; a.click();
        }
    </script>
</body>
</html>
